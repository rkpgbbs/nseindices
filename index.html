<!DOCTYPE html>
<html>
<head>
  <title>NSE Indices Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { font-family: Arial, sans-serif; }
    .table th { background-color: #4CAF50; color: white; position: sticky; top: 0; }
    .positive { color: green; }
    .negative { color: red; }
    .metric-cell { text-align: right; }
    .loading { text-align: center; padding: 50px; font-size: 18px; }
    .header-cell { min-width: 120px; }
  </style>
</head>
<body>
  <div class="container-fluid mt-4">
    <h1 class="text-center mb-4">NSE Indices Performance Dashboard</h1>
    <div id="loading" class="loading">Loading and calculating data... (This may take a minute)</div>
    <div class="table-responsive">
      <table class="table table-striped table-hover" id="dataTable">
        <thead class="table-dark"></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    // REPLACE with your actual Web App URL
    const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzrBzVatYPV12J8lQ_ZRAJJS0binepFLd75gcecQcKop3FP2sK435G5Wml_PqHVsB_mxA/exec';
    
    // Calculation functions
    function calculateCAGR(prices, dates, years) {
      if (prices.length < 2) return null;
      
      const startIndex = Math.max(0, prices.length - Math.floor(years * 252) - 1);
      const endIndex = prices.length - 1;
      
      if (startIndex >= endIndex) return null;
      
      const startPrice = prices[startIndex];
      const endPrice = prices[endIndex];
      
      if (startPrice <= 0 || endPrice <= 0) return null;
      
      const actualYears = (dates[endIndex] - dates[startIndex]) / (1000 * 60 * 60 * 24 * 365.25);
      if (actualYears <= 0) return null;
      
      return (Math.pow(endPrice / startPrice, 1 / actualYears) - 1) * 100;
    }

    function calculateRollingReturn(prices, period) {
      if (prices.length < period + 1) return null;
      const startIndex = prices.length - period - 1;
      const endIndex = prices.length - 1;
      const returnVal = ((prices[endIndex] - prices[startIndex]) / prices[startIndex]) * 100;
      return isNaN(returnVal) ? null : returnVal;
    }

    function calculateVolatility(prices, period) {
      if (prices.length < period + 2) return null;
      
      const recentPrices = prices.slice(-period - 1);
      const returns = [];
      
      for (let i = 1; i < recentPrices.length; i++) {
        if (recentPrices[i-1] > 0) {
          const returnVal = (recentPrices[i] - recentPrices[i-1]) / recentPrices[i-1];
          returns.push(returnVal);
        }
      }
      
      if (returns.length < 2) return null;
      
      const avg = returns.reduce((a, b) => a + b, 0) / returns.length;
      const variance = returns.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / (returns.length - 1);
      return Math.sqrt(variance) * Math.sqrt(252) * 100;
    }

    function calculateMaxDrawdown(prices) {
      if (prices.length < 2) return null;
      
      let peak = prices[0];
      let maxDrawdown = 0;
      
      for (let i = 1; i < prices.length; i++) {
        if (prices[i] > peak) {
          peak = prices[i];
        } else if (peak > 0) {
          const drawdown = (peak - prices[i]) / peak;
          if (drawdown > maxDrawdown) {
            maxDrawdown = drawdown;
          }
        }
      }
      
      return maxDrawdown * 100;
    }

    function calculateSharpeRatio(cagr, volatility) {
      if (volatility === null || volatility === 0) return null;
      const riskFreeRate = 6.5;
      return (cagr - riskFreeRate) / volatility;
    }

    function formatValue(value, isPercentage = true) {
      if (value === null || value === undefined || isNaN(value)) return '-';
      if (isPercentage) {
        return value.toFixed(2) + '%';
      } else {
        return value.toFixed(2);
      }
    }

    function getValueClass(value) {
      if (value === null || value === '-' || value === 0) return '';
      return value > 0 ? 'positive' : 'negative';
    }

    async function loadData() {
      try {
        const response = await fetch(WEB_APP_URL);
        const rawData = await response.json();
        
        if (rawData.error) {
          document.getElementById('loading').innerHTML = 'Error: ' + rawData.error;
          return;
        }
        
        // Process data and calculate metrics
        const processedData = processData(rawData);
        buildTable(processedData);
        
      } catch (error) {
        document.getElementById('loading').innerHTML = 'Error loading data: ' + error.message;
        console.error(error);
      }
    }

    function processData(rawData) {
      if (rawData.length < 2) return [];
      
      const headers = rawData[0];
      const rows = rawData.slice(1);
      
      // Convert date strings to Date objects and filter valid rows
      const validRows = rows.filter(row => row[0] && !isNaN(new Date(row[0]).getTime()));
      const dates = validRows.map(row => new Date(row[0]));
      
      // Get index column indices (B to AQ = columns 1 to 42)
      const indexColumns = [];
      for (let i = 1; i <= 42; i++) {
        if (i < headers.length) {
          indexColumns.push({
            name: headers[i],
            columnIndex: i
          });
        }
      }
      
      // Process each index
      const results = [];
      
      indexColumns.forEach(indexInfo => {
        const prices = [];
        const indexDates = [];
        
        // Extract valid price data for this index
        validRows.forEach((row, rowIndex) => {
          const price = parseFloat(row[indexInfo.columnIndex]);
          if (!isNaN(price) && price > 0) {
            prices.push(price);
            indexDates.push(dates[rowIndex]);
          }
        });
        
        if (prices.length < 10) {
          // Not enough data
          results.push({
            indexName: indexInfo.name,
            dataPoints: prices.length,
            cagr3m: null, cagr6m: null, cagr1y: null, cagr3y: null, cagr5y: null,
            cagr15y: null, cagr20y: null,
            rolling6m: null, rolling1y: null, rolling3y: null, rolling5y: null,
            median1y: null, median3y: null, median5y: null,
            vol1y: null, vol5y: null, vol15y: null, vol20y: null,
            maxDrawdown: null, sharpeRatio: null
          });
          return;
        }
        
        // Calculate all metrics
        const result = {
          indexName: indexInfo.name,
          dataPoints: prices.length
        };
        
        // CAGR calculations
        result.cagr3m = calculateCAGR(prices, indexDates, 0.25);
        result.cagr6m = calculateCAGR(prices, indexDates, 0.5);
        result.cagr1y = calculateCAGR(prices, indexDates, 1);
        result.cagr3y = calculateCAGR(prices, indexDates, 3);
        result.cagr5y = calculateCAGR(prices, indexDates, 5);
        result.cagr15y = calculateCAGR(prices, indexDates, 15);
        result.cagr20y = calculateCAGR(prices, indexDates, 20);
        
        // Rolling returns
        result.rolling6m = calculateRollingReturn(prices, Math.min(126, prices.length - 1));
        result.rolling1y = calculateRollingReturn(prices, Math.min(252, prices.length - 1));
        result.rolling3y = calculateRollingReturn(prices, Math.min(756, prices.length - 1));
        result.rolling5y = calculateRollingReturn(prices, Math.min(1260, prices.length - 1));
        
        // Volatility
        result.vol1y = calculateVolatility(prices, Math.min(252, prices.length - 2));
        result.vol5y = calculateVolatility(prices, Math.min(1260, prices.length - 2));
        result.vol15y = calculateVolatility(prices, Math.min(3780, prices.length - 2));
        result.vol20y = calculateVolatility(prices, Math.min(5040, prices.length - 2));
        
        // Max Drawdown (use all available data)
        result.maxDrawdown = calculateMaxDrawdown(prices);
        
        // Sharpe Ratio
        result.sharpeRatio = calculateSharpeRatio(result.cagr1y, result.vol1y);
        
        results.push(result);
      });
      
      return results;
    }

    function buildTable(data) {
      if (data.length === 0) {
        document.getElementById('loading').innerHTML = 'No data available';
        return;
      }
      
      // Define columns
      const columns = [
        { key: 'indexName', label: 'Index Name', width: '200px' },
        { key: 'dataPoints', label: 'Data Points', width: '100px' },
        { key: 'cagr3m', label: 'CAGR (3M)', width: '100px' },
        { key: 'cagr6m', label: 'CAGR (6M)', width: '100px' },
        { key: 'cagr1y', label: 'CAGR (1Y)', width: '100px' },
        { key: 'cagr3y', label: 'CAGR (3Y)', width: '100px' },
        { key: 'cagr5y', label: 'CAGR (5Y)', width: '100px' },
        { key: 'cagr15y', label: 'CAGR (15Y)', width: '100px' },
        { key: 'cagr20y', label: 'CAGR (20Y)', width: '100px' },
        { key: 'rolling6m', label: 'Rolling (6M)', width: '120px' },
        { key: 'rolling1y', label: 'Rolling (1Y)', width: '120px' },
        { key: 'rolling3y', label: 'Rolling (3Y)', width: '120px' },
        { key: 'rolling5y', label: 'Rolling (5Y)', width: '120px' },
        { key: 'vol1y', label: 'Vol (1Y)', width: '100px' },
        { key: 'vol5y', label: 'Vol (5Y)', width: '100px' },
        { key: 'vol15y', label: 'Vol (15Y)', width: '100px' },
        { key: 'vol20y', label: 'Vol (20Y)', width: '100px' },
        { key: 'maxDrawdown', label: 'Max Drawdown', width: '120px' },
        { key: 'sharpeRatio', label: 'Sharpe Ratio', width: '120px' }
      ];
      
      // Build header
      let headerHTML = '<tr>';
      columns.forEach(col => {
        headerHTML += `<th style="min-width: ${col.width};">${col.label}</th>`;
      });
      headerHTML += '</tr>';
      document.querySelector('#dataTable thead').innerHTML = headerHTML;
      
      // Build rows
      let rowsHTML = '';
      data.forEach(row => {
        rowsHTML += '<tr>';
        columns.forEach(col => {
          let value = row[col.key];
          let displayValue = formatValue(value, col.key !== 'dataPoints' && col.key !== 'sharpeRatio');
          let valueClass = getValueClass(value);
          rowsHTML += `<td class="metric-cell ${valueClass}">${displayValue}</td>`;
        });
        rowsHTML += '</tr>';
      });
      
      document.querySelector('#dataTable tbody').innerHTML = rowsHTML;
      document.getElementById('loading').style.display = 'none';
    }

    // Load data when page loads
    window.onload = loadData;
  </script>
</body>
</html>
